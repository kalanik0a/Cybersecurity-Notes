# 010editor

### `Hex Editor` | `Hex Viewer` | `Forensics`

https://www.sweetscape.com/010editor/

010 Editor: World's Best Hex Editor
Unequalled binary editing performance for files of any size.
Use powerful Binary Templates technology to understand binary data.
Edit 280+ formats.
Find and fix problems with hard drives, memory keys, flash drives, CD-ROMs, etc.
Investigate and modify memory from processes.
Digital forensics, reverse engineering and data recovery.

# 7zip

### `Compression Tools` | `Decompressor`
https://www.7-zip.org/

- High compression ratio in 7z format with LZMA and LZMA2 compression
- Supported formats:
  - Packing / unpacking: 7z, XZ, BZIP2, GZIP, TAR, ZIP and WIM
  - Unpacking only: APFS, AR, ARJ, CAB, CHM, CPIO, CramFS, DMG, EXT, FAT, GPT, HFS, IHEX, ISO, LZH, LZMA, MBR, MSI, NSIS, NTFS, QCOW2, RAR, RPM, SquashFS, UDF, UEFI, VDI, VHD, VHDX, VMDK, XAR and Z.
- For ZIP and GZIP formats, 7-Zip provides a compression ratio that is 2-10 % better than the ratio provided by PKZip and WinZip
- Strong AES-256 encryption in 7z and ZIP formats
- Self-extracting capability for 7z format
- Integration with Windows Shell
- Powerful File Manager
- Powerful command line version
- Plugin for FAR Manager
- Localizations for 87 languages

# apimonitor

### `Binary Analysis` | `Debugger` | `Malware Analysis`

API Monitor is a free software that lets you monitor and control API calls made by applications and services. Its a powerful tool for seeing how applications and services work or for tracking down problems that you have in your own applications.

http://www.rohitab.com/apimonitor

# apktool

### `Android` | `Java` | `Dalvik`

A tool for reverse engineering Android apk files

https://apktool.org/

# bindiff

### `Diff Tool` | `Program`

![](bindiff_scr1.gif)
https://github.com/google/bindiff

# blobrunner
BlobRunner is a simple tool to quickly debug shellcode extracted during malware analysis.

BlobRunner allocates memory for the target file and jumps to the base (or offset) of the allocated memory. This allows an analyst to quickly debug into extracted artifacts with minimal overhead and effort.

https://github.com/OALabs/BlobRunner

# bytecode viewer

### `Java` | `Binary Analysis`

An advanced yet user friendly
Java Reverse Engineering suite

Six different Java decompilers, two Bytecode editors, a Java compiler,plugins, searching, supports loading from Classes, Jars, Android APKs and more.

* Easy to use yet extremely effective.
* Written to run on Java 7, supports Java 8.
* Compile Decompiled Java classes with Ranino Compiler.
* Quickly decompile classes using JD-Core.
* Easily edit APKs via Smali/Baksmali integration.
* Java Decompiling with Six different decompilers (DJ-GUI/Core, Procyon, CFR, Fernflower, Krakatau, and JADX-Core).
* Bytecode Decompiling with CFIDE.
* Android APK integrated with Dex2Jar.
* Securely launch Java applications and insert hooks via EZ-Injection.
* Scan for malicious code with the Malicious Code Scanner plugin.
* Export as DEX, Jar, Class, Zip or Java Source File.
* Open Android APKs, Android DEX, Java Class Files and Java Jars. (WAR & JSP Support!)
* Extensively configurable, over 100+ settings!
* Works seamlessly with all Operating Systems.
* Integrate BCV into Windows by installing it, it'll associate all .class, .dex and .apk to open with BCV.
* View Jar & APK Resources with ease by APKTool.jar integration.
* 100% free and open sourced under GPL v3 CopyLeft.
* Want a more in-depth article about BCV? Click here.
https://bytecodeviewer.com/

# CAPA

### `Malware Analysis` | `Binary Analysis` | `PE Files` | `.NET` | `Shellcode`

capa detects capabilities in executable files. You run it against a PE, ELF, .NET module, shellcode file, or a sandbox report and it tells you what it thinks the program can do. For example, it might suggest that the file is a backdoor, is capable of installing services, or relies on HTTP to communicate.

https://github.com/mandiant/capa

# cmder

### `Shell` | `Program`

Cmder is a software package created out of pure frustration over the absence of nice console emulators on Windows. It is based on amazing software, and spiced up with the Monokai color scheme and a custom prompt layout, looking sexy from the start.

https://cmder.app/

# CodeTrack

### `.NET` | `Binary Analysis` | `Debugger`

CodeTrack is made for .NET components

CodeTrack is a versatile profiler with some extra tricks up its sleeve.
On top of the profiling features it also allows debugging and analyzing code execution.

https://www.getcodetrack.com/

https://youtu.be/8_kvOhGq8fQ

# Cyberchef

### `Encoding` | `Decoding` | `Encrypter` | `Decrypter` 

CyberChef is a simple, intuitive web app for carrying out all manner of "cyber" operations within a web browser. These operations include simple encoding like XOR and Base64, more complex encryption like AES, DES and Blowfish, creating binary and hexdumps, compression and decompression of data, calculating hashes and checksums, IPv6 and X.509 parsing, changing character encodings, and much more.

The tool is designed to enable both technical and non-technical analysts to manipulate data in complex ways without having to deal with complex tools or algorithms. It was conceived, designed, built and incrementally improved by an analyst in their 10% innovation time over several years.

https://github.com/gchq/CyberChef

# Cygwin

### `Toolkit` | `Operating Environment` | `Program` | `Shell`

a large collection of GNU and Open Source tools which provide functionality similar to a Linux distribution on Windows.

a DLL (cygwin1.dll) which provides substantial POSIX API functionality.

https://cygwin.org/

# de4dot-cex

### `C` | `Deobfuscator` | `Decryptor`

C Code Deobfuscator

- Supports x86 (native) mode
- Supports normal mode
- Decrypts and inlines constants
- Decrypts resources
- Fixes control flow
- Fixes proxy calls
- Deobfuscated assemblies are runnable

https://github.com/ViRb3/de4dot-cex

# Dependency Walker

### `Binary Analysis` | `Malware Analysis` | `PE Files`  | `DLL`

Dependency Walker is a free utility that scans any 32-bit or 64-bit Windows module (exe, dll, ocx, sys, etc.) and builds a hierarchical tree diagram of all dependent modules. For each module found, it lists all the functions that are exported by that module, and which of those functions are actually being called by other modules. Another view displays the minimum set of required files, along with detailed information about each file including a full path to the file, base address, version numbers, machine type, debug information, and more.

Dependency Walker is also very useful for troubleshooting system errors related to loading and executing modules. Dependency Walker detects many common application problems such as missing modules, invalid modules, import/export mismatches, circular dependency errors, mismatched machine types of modules, and module initialization failures.

Dependency Walker runs on Windows 95, 98, Me, NT, 2000, XP, 2003, Vista, 7, and 8. It can process any 32-bit or 64-bit Windows module, including ones designed for Windows CE. It can be run as graphical application or as a console application. Dependency Walker handles all types of module dependencies, including implicit, explicit (dynamic / runtime), forwarded, delay-loaded, and injected. A detailed help is included.

Dependency Walker is completely free to use. However, you may not profit from the distribution of it, nor may you bundle it with another product.

https://www.dependencywalker.com/

# dex2jar 

### `Android` | `Dalvik`

dex-reader is designed to read the Dalvik Executable (.dex/.odex) format. It has a light weight API similar with ASM. An example here dex-translator is designed to do the convert job. It reads the dex instruction to dex-ir format, after some optimize, convert to ASM format. dex-ir used by dex-translator, is designed to represent the dex instruction dex-tools tools to work with .class files.

https://github.com/pxb1988/dex2jar

# Didier Stevens Suite

### `Toolkit` | `Malware Analysis` | `Reverse Engineering` | `Network Tools` | `Program` | `Debugger`

https://blog.didierstevens.com/my-software/

# die - Detect it Easy

### `Malware Analysis` | `PE Files` | `ELF Files` | `Binary Analysis`

Detect It Easy, or abbreviated "DIE" is a program for determining types of files.

DIE is a cross-platform application, apart from Windows version there are also available versions for Linux and Mac OS.

Many programs of the kind (PEID, PE tools) allow to use third-party signatures. Unfortunately, those signatures scan only bytes by the pre-set mask, and it is not possible to specify additional parameters. As the result, false triggering often occur. More complicated algorithms are usually strictly set in the program itself. Hence, to add a new complex detect one needs to recompile the entire project. No one, except the authors themselves, can change the algorithm of a detect. As time passes, such programs lose relevance without the constant support.

Detect It Easy has totally open architecture of signatures. You can easily add your own algorithms of detects or modify those that already exist. This is achieved by using scripts. The script language is very similar to JavaScript and any person, who understands the basics of programming, will understand easily how it works. Possibly, someone may decide the scripts are working very slow. Indeed, scripts run slower than compiled code, but, thanks to the good optimization of Script Engine, this doesn't cause any special inconvenience. The possibilities of open architecture compensate these limitations.

DIE exists in three versions. Basic version ("die"), Lite version ("diel") and console version ("diec"). All the three use the same signatures, which are located in the folder "db". If you open this folder, nested sub-folders will be found ("Binary", "PE" and others). The names of sub-folders correspond to the types of files. First, DIE determines the type of file, and then sequentially loads all the signatures, which lie in the corresponding folder. Currently the program defines the following types:

- MSDOS executable files MS-DOS
- PE executable files Windows
- ELF executable files Linux
- MACH executable files Mac OS
- Binary all other files

https://github.com/horsicq/Detect-It-Easy

# DLL To EXE

### `Binary Files` | `DLLs`

https://github.com/hasherezade/dll_to_exe

https://hshrzd.wordpress.com/2016/07/21/how-to-turn-a-dll-into-a-standalone-exe/

# DNSpyEx

### `.NET` | `Debugger` | `Assembly`

dnSpyEx is an unofficial continuation of the dnSpy project which is a debugger and .NET assembly editor. You can use it to edit and debug assemblies even if you don't have any source code available. Main features:

- Debug .NET and Unity assemblies
- Edit .NET and Unity assemblies
- Light and dark themes
- See below for more features

- Debug .NET Framework, .NET and Unity game assemblies, no source code required
- Set breakpoints and step into any assembly
- Locals, watch, autos windows
- Variables windows support saving variables (eg. decrypted byte arrays) to disk or view them in the hex editor (memory window)
- Object IDs
- Multiple processes can be debugged at the same time
- Break on module load
- Tracepoints and conditional breakpoints
- Export/import breakpoints and tracepoints
- Optional Just My Code (JMC) stepping filters for system libraries
- Call stack, threads, modules, processes windows
- Break on thrown exceptions (1st chance)
- Variables windows support evaluating C# / Visual Basic expressions
Dynamic modules can be debugged (but not dynamic methods due to CLR limitations)
- Output window logs various debugging events, and it shows timestamps by default :)
- Assemblies that decrypt themselves at runtime can be debugged, dnSpy will use the in-memory image. You can also force dnSpy to always use in-memory images instead of disk files.
- Bypasses for common debugger detection techniques
- Public API, you can write an extension or use the C# Interactive window to control the debugger

https://github.com/dnSpyEx/dnSpy


# DotDumper
### `.NET` | `Malware Analysis`

An automatic unpacker and logger for DotNet Framework targeting files! This tool has been unveiled at Black Hat USA 2022. At Black Hat Asia 2023, DotDumperGUI and DotDumperNative were published, along with version 1.1-stable of DotDumper. These three tools are meant to be used together, where DotDumper 1.1-stable requires DotDumperNative's DLLs to be present, while DotDumperGUI is meant as a graphical user-interface to open and filter the JSON output from DotDumper runs.

The automatic detection and classification of any given file in a reliable manner is often considered the holy grail of malware analysis. The trials and tribulations to get there are plenty, which is why the creation of such a system is held in high regard. When it comes to DotNet targeting binaries, our new open-source tool DotDumper aims to assist in several of the crucial steps along the way: logging (in-memory) activity, dumping interesting memory segments, and extracting characteristics from the given sample.

https://github.com/advanced-threat-research/DotDumper

# Explorer Suite

### `Toolkit` | `Reverse-Engineering` | `Malware Analysis` | `PE Files` | `Binary Analysis` 

### Features
- Process Viewer
- Drivers Viewer
- Windows Viewer
- PE and Memory Dumper
- Full support for PE32/64
- Special fields description and modification (.NET supported)
- PE Utilities
- PE Rebuilder (with Realigner, IT Binder, Reloc Remover, Strong Name Signature Remover, Image Base Changer)
- View and modification of .NET internal structures
- Resource Editor (full support for Windows Vista icons)
- Support in the Resource Editor for .NET resources (dumpable as well)
- Hex Editor
- Import Adder
- PE integrity checks
- Extension support
- Visual Studio Extensions Wizard
- Powerful scripting language
- Dependency Walker
- Quick Disassembler (x86, x64, MSIL)
- Name Unmangler
- Extension support
- File Scanner
- Directory Scanner
- Deep Scan method
- Recursive Scan method
- Multiple results
- Report generation
- Signatures Manager
- Signatures Updater
- Signatures Collisions Checker
- Signatures Retriever

https://ntcore.com/explorer-suite/

# ExtremeDumper

### `.NET` | `Reverse-Engineering` | `Binary Analysis`
- List all processes and highlight .NET processes
- List all modules in a process and highlight .NET modules
- Walk memory pages and dump all valid .NET assemblies
- Dump specified module in modules view
- Inject .NET assembly into any process
- Enhanced anti-dump bypass mode
- .NET assembly loader hook
- Anti title keyword detection
- Portable and only one executable file

The default page is process view. You can right click here to dump all .NET modules and view modules in selected process. And also you can click "Inject Dll" to inject a .NET assembly into any process. Any process which contains desktop clr or coreclr will be marked as green.

https://github.com/wwh1004/ExtremeDumper


# EZViewer

### `File Viewer` | `Program`

A standalone, zero dependency viewer for .doc, .docx, .xls, .xlsx, .txt, .log, .rtf, .otd, .htm, .html, .mht, .csv, and .pdf. Any non-supported files are shown in a hex editor (with data interpreter!).

https://www.sans.org/tools/ezviewer/

# Mandiant Flare Fakenet-ng 

### `Network Simulator` | `Program`

FakeNet-NG 3.2 is a next generation dynamic network analysis tool for malware analysts and penetration testers. It is open source and designed for the latest versions of Windows (and Linux, for certain modes of operation). FakeNet-NG is based on the excellent Fakenet tool developed by Andrew Honig and Michael Sikorski.

The tool allows you to intercept and redirect all or specific network traffic while simulating legitimate network services. Using FakeNet-NG, malware analysts can quickly identify malware's functionality and capture network signatures. Penetration testers and bug hunters will find FakeNet-NG's configurable interception engine and modular framework highly useful when testing application's specific functionality and prototyping PoCs.

https://github.com/mandiant/flare-fakenet-ng

# FLARE Obfuscated String Solver 

### `Malware Analysis` | `Deobfuscator` | `Binary Analysis`

The FLARE Obfuscated String Solver (FLOSS, formerly FireEye Labs Obfuscated String Solver) uses advanced static analysis techniques to automatically extract and deobfuscate all strings from malware binaries. You can use it just like strings.exe to enhance the basic static analysis of unknown binaries.

Obfuscated Strings
Rather than heavily protecting backdoors with hardcore packers, many malware authors evade heuristic detections by obfuscating only key portions of an executable. Often, these portions are strings and resources used to configure domains, files, and other artifacts of an infection. These key features will not show up as plaintext in the output of the strings.exe utility that we commonly use during basic static analysis.

FLOSS extracts all the following string types:

static strings: "regular" ASCII and UTF-16LE strings
stack strings: strings constructed on the stack at run-time
tight strings: a special form of stack strings, decoded on the stack
decoded strings: strings decoded in a function
Please review the theory behind FLOSS [here](https://github.com/mandiant/flare-floss/blob/master/doc/theory.md).

[Our blog post](https://www.mandiant.com/resources/automatically-extracting-obfuscated-strings) talks more about the motivation behind FLOSS and details how the tool works.

FLOSS version 2.0 updates are detailed in this [blog post](https://www.mandiant.com/resources/floss-version-2).

FLOSS also contains additional Python scripts in the [scripts directory](https://github.com/mandiant/flare-floss/blob/master/scripts) which can be used to load its output into other tools such as Binary Ninja or IDA Pro. For detailed description of these scripts review the documentation [here](https://github.com/mandiant/flare-floss/blob/master/scripts/README.md).

https://github.com/mandiant/flare-floss

# Ghidra

### `Reverse-Engineering` | `Malware Analysis`

Ghidra is a software reverse engineering (SRE) framework created and maintained by the [National Security Agency](https://www.nsa.gov/) Research Directorate. This framework includes a suite of full-featured, high-end software analysis tools that enable users to analyze compiled code on a variety of platforms including Windows, macOS, and Linux. Capabilities include disassembly, assembly, decompilation, graphing, and scripting, along with hundreds of other features. Ghidra supports a wide variety of processor instruction sets and executable formats and can be run in both user-interactive and automated modes. Users may also develop their own Ghidra extension components and/or scripts using Java or Python.

In support of NSA's Cybersecurity mission, Ghidra was built to solve scaling and teaming problems on complex SRE efforts, and to provide a customizable and extensible SRE research platform. NSA has applied Ghidra SRE capabilities to a variety of problems that involve analyzing malicious code and generating deep insights for SRE analysts who seek a better understanding of potential vulnerabilities in networks and systems.

If you are a U.S. citizen interested in projects like this, to develop Ghidra and other cybersecurity tools for NSA to help protect our nation and its allies, consider applying for a [career with us](https://www.intelligencecareers.gov/nsa).

https://ghidra-sre.org/

# GoReSym 

### `Go` | `Reverse-Engineering`

GoReSym is a Go symbol parser that extracts program metadata (such as CPU architecture, OS, endianness, compiler version, etc), function metadata (start & end addresses, names, sources), filename and line number metadata, and embedded structures and types. This cross platform program is based directly on the [open source Go compiler](https://github.com/golang/go/tree/master/src/debug/gosym) and runtime code.

The upstream Go runtime code is extended to handle:

- stripped binaries
- malformed unpacked binaries, such as from UPX
- binaries that split single data ranges across multiple sections
- the location of the moduledata structure


https://github.com/mandiant/GoReSym

# hashmyfiles

### `Hashing Tool` | `SHA1` | `MD5`

HashMyFiles is small utility that allows you to calculate the MD5 and SHA1 hashes of one or more files in your system. You can easily copy the MD5/SHA1 hashes list into the clipboard, or save them into text/html/xml file.
HashMyFiles can also be launched from the context menu of Windows Explorer, and display the MD5/SHA1 hashes of the selected file or folder.

https://www.nirsoft.net/utils/hash_my_files.html

# hollows_hunter 

### `Malware Detector`

Scans all running processes. Recognizes and dumps a variety of potentially malicious implants (replaced/implanted PEs, shellcodes, hooks, in-memory patches).

Uses: [PE-sieve](https://github.com/hasherezade/pe-sieve.git)

https://github.com/hasherezade/hollows_hunter

# HxD - Freeware Hex Editor and Disk Editor

### `Hex Editor` | `Program` | `Memory Editor`

HxD is a carefully designed and fast hex editor which, additionally to raw disk editing and modifying of main memory (RAM), handles files of any size.

The easy to use interface offers features such as searching and replacing, exporting, checksums/digests, insertion of byte patterns, a file shredder, concatenation or splitting of files, statistics and much more.

Editing works like in a text editor with a focus on a simple and task-oriented operation, as such functions were streamlined to hide differences that are purely technical.
For example, drives and memory are presented similar to a file and are shown as a whole, in contrast to a sector/region-limited view that cuts off data which potentially belongs together. Drives and memory can be edited the same way as a regular file including support for undo. In addition memory-sections define a foldable region and inaccessible sections are hidden by default.

Furthermore a lot of effort was put into making operations fast and efficient, instead of forcing you to use specialized functions for technical reasons or arbitrarily limiting file sizes. This includes a responsive interface and progress indicators for lengthy operations.

https://mh-nexus.de/en/hxd/

# CAPA IDA Plugin 

### `IDA` | `Malware Analysis`

### IDA Pro is required**

capa explorer is an IDAPython plugin that integrates the FLARE team's open-source framework, capa, with IDA Pro. capa is a framework that uses a well-defined collection of rules to identify capabilities in a program. You can run capa against a PE file, ELF file, or shellcode and it tells you what it thinks the program can do. For example, it might suggest that the program is a backdoor, can install services, or relies on HTTP to communicate. capa explorer runs capa analysis on your IDA Pro database (IDB) without needing access to the original binary file. Once a database has been analyzed, capa explorer helps you identify interesting areas of a program and build new capa rules using features extracted from your IDB.

https://github.com/mandiant/capa/blob/master/capa/ida/plugin/README.md

# COMIda Plugin

### `IDA` | `COM`

An IDA Plugin that help during the analysis of modules using COM. It works by searching data references to known COM GUID (Classes or Interfaces), and for hex-ray plugin user, infers type that use :

- `CoCreateInstance` function
- `CoGetCallContext` function
- `QueryInterface` method

https://github.com/airbus-cert/comida

# IDA Plugin deREferencing

### `IDA` | `Reverse-Engineering` | `Assembly`

deReferencing is an IDA Pro plugin that implements new registers and stack views. Adds dereferenced pointers, colors and other useful information, similar to some GDB plugins (e.g: PEDA, GEF, pwndbg, etc).

Supports following architectures: x86, x86-64, ARM, ARM64, MIPS32 and MIPS64

https://github.com/danigargu/deREferencing

# IDA Plugin diaphora

### `IDA` | `Diff Tool` | `Python`

Diaphora (διαφορά, Greek for 'difference') version 3.1.2 is the most advanced program diffing tool (working as an IDA plugin) available as of today (2024). It was released first during SyScan 2015 and has been actively maintained ever since: Diaphora has been ported to every single minor version of IDA since 6.8 to 8.4.

Diaphora supports versions of IDA >= 7.4 because the code only runs in Python 3.X (Python 3.11 was the last version being tested).

https://github.com/joxeankoret/diaphora

# IDA Flare Repository

### `IDA` | `Reverse-Engineering`

This repository contains a collection of IDA Pro scripts and plugins used by the FireEye Labs Advanced Reverse Engineering (FLARE) team.

https://github.com/mandiant/flare-ida

# IDA IFL - Interactive Function List

### `IDA` | `PE Files` | `Reverse Engineering`

A small plugin with a goal to provide user-friendly way to navigate between functions and their references.
Additionally, it allows to import reports generated by i.e. PE-sieve into IDA. Supports:

- .tag format (generated by PE-sieve, Tiny Tracer, PE-bear)
- .imports.txt format (generated by PE-sieve)

https://github.com/hasherezade/ida_ifl


# IDA Free

### `IDA` | `Assembly` | `x86_64` | `Binaries` | `Reverse-Engineering` | `Malware Analysis`

- Analyze both 32-bit and 64-bit applications
- Cloud-based x86/x64 decompiler
- Local x86/x64 debugger included
- Support x86/x64 processors
- Save your analysis results
- Perpetual license

https://hex-rays.com/ida-free/

# IDR - Irreproducible Discovery Rate

### `Signal Analysis`

The IDR (Irreproducible Discovery Rate) framework is a uniﬁed approach to measure the reproducibility of ﬁndings identiﬁed from replicate experiments and provide highly stable thresholds based on reproducibility. Unlike the usual scalar measures of reproducibility, the IDR approach creates a curve, which quantitatively assesses when the ﬁndings are no longer consistent across replicates. In layman's terms, the IDR method compares a pair of ranked lists of identifications (such as ChIP-seq peaks). These ranked lists should not be pre-thresholded i.e. they should provide identifications across the entire spectrum of high confidence/enrichment (signal) and low confidence/enrichment (noise). The IDR method then fits the bivariate rank distributions over the replicates in order to separate signal from noise based on a defined confidence of rank consistency and reproducibility of identifications i.e the IDR threshold.

https://github.com/nboley/idr

# IFPSTools.NET

### `Pascal` | `.NET`

Successor to IFPSTools; for working with RemObject PascalScript compiled bytecode files.

Written in C#, libraries target .NET Standard 2.0 and console applications target .NET Framework.

Contains the following:

https://github.com/Wack0/IFPSTools.NET

# ILSpy 

### `.NET` | `Reverse-Engineering Tool`

ILSpy is the open-source .NET assembly browser and decompiler.

Download: latest release | latest CI build (master) | Microsoft Store (RTM versions only)

### Decompiler Frontends
Aside from the WPF UI ILSpy (downloadable via Releases, see also plugins), the following other frontends are available:

- Visual Studio 2022 ships with decompilation support for F12 enabled by default (using our engine v8.1).
- In Visual Studio 2019, you have to manually enable F12 support. Go to Tools / Options / Text Editor /  C# / Advanced and check "Enable navigation to decompiled source"
- C# for Visual Studio Code ships with decompilation support as well. To enable, activate the setting "Enable Decompilation Support".
- Our Visual Studio 2022 extension marketplace
- Our Visual Studio 2017/2019 extension marketplace
- Our Visual Studio Code Extension repository | marketplace
- Our Linux/Mac/Windows ILSpy UI based on Avalonia - check out https://github.com/icsharpcode/AvaloniaILSpy
- Our ICSharpCode.Decompiler NuGet for your own projects
- Our dotnet tool for Linux/Mac/Windows - check out ILSpyCmd in this repository
- Our Linux/Mac/Windows PowerShell cmdlets in this repository

### Features
- Decompilation to C# (check out the language support status)
- Whole-project decompilation
- Search for types/methods/properties (learn about the options)
- Hyperlink-based type/method/property navigation
- Base/Derived types navigation, history
- Assembly metadata explorer (feature walkthrough)
- BAML to XAML decompiler
- ReadyToRun binary support for .NET Core (see the tutorial)
- Extensible via plugins
- Additional features in DEBUG builds (for the devs)

https://github.com/icsharpcode/ILSpy

# InnoExtract

### `Reverse-Engineering` | `Inno Setup` | `Decompressor`

Inno Setup is a tool to create installers for Microsoft Windows applications. innoextract allows to extract such installers under non-Windows systems without running the actual installer using wine. innoextract currently supports installers created by Inno Setup 1.2.10 to 6.2.2.

In addition to standard Inno Setup installers, innoextract also supports some modified Inno Setup variants including Martijn Laan's My Inno Setup Extensions 1.3.10 to 3.0.6.1 as well as GOG.com's Inno Setup-based game installers. innoextract is able to unpack Wadjet Eye Games installers (to play with AGS), Arx Fatalis patches (for use with Arx Libertatis) as well as various other Inno Setup executables.

innoextract is available under the ZLIB license - see the LICENSE file.

https://github.com/dscharrer/innoextract?tab=readme-ov-file

https://constexpr.org/innoextract/install

# Innounp, the Inno Setup Unpacker

### `Reverse-Engineering` | `Inno Setup` | `Decompressor`
Inno Setup is a popular program for making software installations. Unfortunately, there is no official unpacker - the only method of getting the files out of the self-extracting executable is to run it. One piece of software that addresses this issue is Sergei Wanin's InstallExplorer, a plug-in for the FAR Manager that unpacks several types of installations, including Inno Setup (IS). But since it is not updated in a timely fashion, and so does not support the latest IS most of the time, this program was born. The advantages over InstallExplorer are:

Innounp is open source and based on IS source. Therefore, it is more likely to support future IS versions.
It recovers portions of the installation script (.iss file), including the registry changes and the compiled Innerfuse/RemObjects Pascal Script, if available.

https://innounp.sourceforge.net/

# ISD ???

# JS-Deobfuscator

### `JavaScript (front-end)`

A simple but powerful deobfuscator to remove common JavaScript obfuscation techniques. Open an issue if there is a feature you think should be implemented.

Online version at deobfuscate.io

Install via `npm install js-deobfuscator`

Looking for a deobfuscator specific to Obfuscator.io/javascript-obfuscator? Try this repo

If you would like to discuss/learn about JavaScript obfuscation and deobfuscation you can join the Discord server

https://github.com/ben-sb/javascript-deobfuscator

# libraries.python3.vm

### `python`

Python is an extensive general purpose cross-platform programming language which powers many tools used in the Linux and Windows data analysis world.

https://www.python.org/downloads/

# Magika

### `python` | `JavaScript` | `Magic Sniffer` | `Binary Analysis`
Magika leverages the power of cutting-edge deep learning to enhance the world of file type detection. It provides increased accuracy and support for a comprehensive range of content types, outperforming traditional tools with 99%+ average precision and recall.

Designed for efficiency, Magika runs quickly even on a single CPU. A similar model currently scans millions of files per second at Google

You can start using Magika by installing it as a Python package: `pip install magika`

Then, you can run it by executing `magika` like so:

You can use Magika in your Python code, or your JavaScript (in Node or client side). In fact, this page is using Magika's JavaScript library!

https://google.github.io/magika/

# malware-jail

### `JavaScript (backend)`

Sandbox for semi-automatic Javascript malware analysis, deobfuscation and payload extraction. Written for Node.js

malware-jail is written for Node's 'vm' sandbox. Currently implements WScript (Windows Scripting Host) context env/wscript.js, at least the part frequently used by malware. Internet browser context is partialy implemented env/browser.js.

Runs on any operating system. Developed and tested on Linux, Node.js v6.6.0.

Due to use of some ES6 features, you'll need Node.js >= 6.x.

See EXAMPLES for malware samples analyzed.

If you have new malware samples, please submit them to javascript-malware-collection, either via issue or pull request.



https://github.com/HynekPetrak/malware-jail

# nasm - Netwide Assembler

### `x86` | `Assembly` | `Toolkit`

This is the project webpage for the Netwide Assembler (NASM), an asssembler for the x86 CPU architecture portable to nearly every modern platform, and with code generation for many platforms old and new.

https://www.nasm.us/

# NETReactorSlayer

### `.NET Eziriz Obfuscator`

NETReactorSlayer is an open source (GPLv3) deobfuscator and unpacker for Eziriz .NET Reactor.

https://github.com/SychicBoy/NETReactorSlayer

https://www.eziriz.com/reactor_download.htm

# GNU netcat

### `commandline` | `remote access`

Netcat is a featured networking utility which reads and writes data across network connections, using the TCP/IP protocol.

It is designed to be a reliable "back-end" tool that can be used directly or easily driven by other programs and scripts. At the same time, it is a feature-rich network debugging and exploration tool, since it can create almost any kind of connection you would need and has several interesting built-in capabilities.

It provides access to the following main features:
- Outbound and inbound connections, TCP or UDP, to or from any ports.
- Featured tunneling mode which allows also special tunneling such as UDP to TCP, with the possibility of specifying all network parameters (source port/interface, listening port/interface, and the remote host allowed to connect to the tunnel.
- Built-in port-scanning capabilities, with randomizer.
- Advanced usage options, such as buffered send-mode (one line every N seconds), and hexdump (to stderr or to a specified file) of trasmitted and received data.
- Optional RFC854 telnet codes parser and responder.

https://netcat.sourceforge.net/

# Notepad++

### `text editor`

Notepad++ is a free (as in “free speech” and also as in “free beer”) source code editor and Notepad replacement that supports several languages. Running in the MS Windows environment, its use is governed by GNU General Public License.

Based on the powerful editing component Scintilla, Notepad++ is written in C++ and uses pure Win32 API and STL which ensures a higher execution speed and smaller program size. By optimizing as many routines as possible without losing user friendliness, Notepad++ is trying to reduce the world carbon dioxide emissions. When using less CPU power, the PC can throttle down and reduce power consumption, resulting in a greener environment.

https://notepad-plus-plus.org/

# Notepad++ Compare Plugin

### `notepad++ plugin` | `diff tool`

Comparison plugin for Notepad++ editor.

Features
- Side-by-side visual differencing
- Comparison against SVN database
- Highlight differences inside lines
- Navigation bar shows a map of compared files
- Moved line detection
- Easy navigation between differences
- Customizable results presentation

https://sourceforge.net/projects/npp-compare/

#  Notepad++ JSTool Plugin

### `notepad++ plugin` | `JSON tool`

A JavaScript (JSON) tool for Notepad++ (formerly JSMinNpp) and Visual Studio Code.
- Douglas Crockford's JSMin algorithm to minimize JavaScript code.
- My own algorithm to format JavaScript code.
- A JSON tree viewer. The JSON tree viewer for Notepad++ can handle >10MB JSON file easily.
- Support 64bit Notepad++ (from version 1.20.0, ".64.zip" package).

Really helpful to JavaScript coder on Notepad++ and Visual Studio Code. Easy to use it.
Made in China.
Project site: http://www.sunjw.us/jstool

#### Features

- JavaScript minify.
- JavaScript/JSON format.
- Sort JSON data alphabetically.
- JSON tree viewer.

https://github.com/sunjw/jstoolnpp

# Notepad++ XMLTools Plugin

### `notepad++ plugin` | `XML optimizer`

This plugin is a small set of useful tools for editing XML with Notepad++. The plugin is based on MSXML. The plugin features are:

- XML syntax Check
- XML Schema (XSD) + DTD Validation
- XML tag autoclose
- Pretty print
- Linarize XML
- Current XML Path
- Conversion XML &lt;-&gt; Text
- Comment / Uncomment
- XPath expression evaluation

Author: Nicolas Crittin
https://github.com/morbac/xmltools

# obfuscator-io-deobfuscator

### `JavaScript` | `Deobfuscator`

A deobfuscator for scripts obfuscated by Obfuscator.io

#### CLI

Install via `npm install -g obfuscator-io-deobfuscator`

Usage: obfuscator-io-deobfuscator <input> -o [output]

https://github.com/ben-sb/obfuscator-io-deobfuscator

# OffVis

### `File-Based Vulnerability Scanner` | `HexViewer`

OffVis displays an OLESS-based binary files in two ways. It shows a hex view of the raw file contents on the left side of the window and the tree of objects built up from parsing those raw file contents on the right side of the window. You can see an example below.



(click to expand)

Double-clicking on a specific byte in the hex view will navigate the tree view to the object that byte belongs to. Double-clicking an object in the tree view navigates the hex view to the bytes that make up the object (and any of its child objects).

OffVis also detects eight Office file format vulnerabilities that we have seen exploited over the past couple years. We chose these specific CVE’s to detect based on prevalence of attacks in the wild. As was discussed in our lastSecurity Intelligence Report, most attacks use vulnerabilities for which a security update has been available for months. We hope this “known-bad” detection will help you analyze suspicious documents that arrive into your network. And if you find malicious samples exploiting product vulnerabiltiies that are not detected , please send them to us so we can consider adding detection to OffVis for more vulnerabilities. We want to keep the correct balance between giving defenders more information to help them detect attacks and keeping vulnerabilities away from attackers. Here’s the initial list of CVE detection included:

| CVE |	Product Bulletin |
|-|-|
| CVE-2006-0009	| PowerPoint MS06-012 (March 2006) |
| CVE-2006-0022	| PowerPoint MS06-028 (June 2006) |
| CVE-2006-2492	| Word	MS06-027 (June 2006) |
| CVE-2006-3434	| Word	MS06-062 (October 2006) | 
| CVE-2007-0671	| Excel	MS07-015 (February 2007) | 
| CVE-2008-0081	| Excel	MS08-014 (March 2008) | 
| CVE-2009-0238	| Excel	MS09-009 (April 2009) | 
| CVE-2009-0556	| PowerPoint	MS09-017 (May 2009) |

In the screenshot below, you can see an OffVis CVE-2009-0556 detection. The PST_OutlineTextRefAtom atom at file offset 766378 has a Type value of 3998 (0xf9e), triggering the detection.



You can find out more about OffVis bydownloading it from the Microsoft Download Center and viewing the readme file. Please email us at switech at Microsoft.com if you have questions, comments, or malicious samples that are not detected.

Thanks to Kevin Brown, Dan Beenfeldt, and the rest of the MSRC Engineering team who worked on this project!

Update Sept 18, 2009: This initial version of OffVis requires .Net framework 3.5. If you encounter errors about being unable to load assembly System.Core version 3.5, please install .Net framework 3.5. The next public release of OffVis will be linked against .Net framework 2.0 which we expect is more widely deployed.

- Jonathan Ness, MSRC Engineering

*Posting is provided “AS IS” with no warranties, and confers no rights.*

https://msrc.microsoft.com/blog/2009/07/announcing-offvis-1-0-beta/

# OneNoteAnalyzer

### `Malware Analysis` | `Reverse Engineering` | `C#` | `.NET` | `OneNote`

A C# based tool for analyzing malicious OneNote documents

### Description
Recently we came across few malicious OneNote Documents been distributed in-the-wild by various threat actors. This gave us an idea to develop "OneNoteAnalyzer" which would help in analysing such malicious OneNote documents without executing them. Now lets take a look at the features that the tool offers.

After providing the file path of the Malicious OneNote document. The OneNoteAnalyzer extracts:

- Attachments from OneNote Document along with the Actual Attachment Path, Filename and size
- Page MetaData from OneNote Document - Title, Author, CreationTime, LastModifiedTime
- Images from OneNote Document along with the HyperLink URLs if any
- Pagewise Text from OneNote Document
- HyperLinks from OneNote Document along with the overlay text
- Converts OneNote Document to Image
- Parses Password Protected OneNote Documents NEW

https://github.com/knight0x07/OneNoteAnalyzer

# PDBReSym

### `Debugger` | `PE File` | `Reverse-Engineering`

https://www.linkedin.com/posts/stephen-eckels-995211102_release-v131-mandiantstrace-activity-7100159031389925377-yrIl

https://github.com/mandiant/STrace

# PDF Stream Dumper

### `PDF` | `Malware Analysis` | `Reverse Engineering` | `Shellcode` | `Deobfuscator`

### Full feature list
- supported filters: FlateDecode, RunLengthDecode, ASCIIHEXDecode, ASCII85Decode, LZWDecode, JBIG2, CCITTFaxDecode, DecodePredictors
- Integrated shellcode tools:
  - sclog gui (Shellcode Analysis tool I wrote at iDefense)
  - scdbg libemu based Shellcode analysis tool
  - Shellcode_2_Exe functionality
  - Export unescaped bytes to file
- supports filter chaining (ie multiple filters applied to same stream)
- supports unescaping encoded pdf headers
- scriptable interface to process multiple files and generate reports
- view all pdf objects
- view deflated streams
- view stream details such as file offsets, header, etc
- save raw and deflated data
- search streams for strings
- scan for functions which contain pdf exploits (dumb scan)
- format javascript using js beautifier (see credits in readme)
- view streams as hex dumps
- zlib compress/decompress arbitrary files
- replace/update pdf streams with your own data
- basic javascript interface so you can run parts of embedded scripts +  support for using MS Script Debugger
- PdfDecryptor w/source - uses iTextSharp and requires .Net Framework 2.0
- Basic Javascript de-obsfuscator
- can hide: header only streams, duplicate streams, selected streams
- js ui also has access to a toolbox class to
  - simplify fragmented strings
  - read/write files
  - do hexdumps
  - do unicode safe unescapes
  - disassembler engine
  - replicate some common Adobe API (new)

### Current Automation scripts include:
- csv_stats.vbs - Builds csv file with results from lower status bar for all files in a directory
- pdfbox_extract.vbs - use pdfbox to extract all images and text from current file
- string_scan.vbs - scan all decompressed streams in all files in a directory for a string you enter
- unsupported_filters.vbs - scan a directory and build list of all pdfs which have unsupported filters
- filter_chains.vbs - recursivly scans parent dir for pdfs that use multiple encoding filters on a stream.
- obsfuscated_headers.vbs - recursivly scans parent dir for pdfs that have obsfuscated object headers
- pdfbox_extract_text_page_by_page.vbs - uses pdfbox to extract page data into individual files

http://sandsprite.com/blogs/index.php?uid=7&pid=57

# PE-Bear

### `PE File` | `Reverse Engineering` | `Malware Analysis`

PE-bear is a multiplatform reversing tool for PE files. Its objective is to deliver fast and flexible “first view” for malware analysts, stable and capable to handle malformed PE files.

Signatures for PE-bear:

- SIG.txt (updated: Oct 17, 2022) - contains signatures from PEid's UserDB - converted by a script provided by crashish

https://github.com/hasherezade/pe-bear

# PEiD

### `PE File` | `Malware Analysis` | `Binary Analysis`

PEiD detects most common packers, cryptors and compilers for PE files. It can currently detect more than 600 different signatures in PE files.

PEiD is special in some aspects when compared to other identifiers already out there!

1. It has a superb GUI and the interface is really intuitive and simple.
2. Detection rates are amongst the best given by any other identifier.
3. Special scanning modes for *advanced* detections of modified and unknown files.
4. Shell integration, Command line support, Always on top and Drag'n'Drop capabilities.
5. Multiple file and directory scanning with recursion.
6. Task viewer and controller.
7. Plugin Interface with plugins like Generic OEP Finder and Krypto ANALyzer.
8. Extra scanning techniques used for even better detections.
9. Heuristic Scanning options.
10. New PE details, Imports, Exports and TLS viewers
11. New built in quick disassembler.
12. New built in hex viewer.
13. External signature interface which can be updated by the user.


There are 3 different and unique scanning modes in PEiD.

The *Normal Mode* scans the PE files at their Entry Point for all documented signatures. This is what all other identifiers also do.

The *Deep Mode* scans the PE file's Entry Point containing section for all the documented signatures. This ensures detection of around 80% of modified and scrambled files.

The *Hardcore Mode* does a complete scan of the entire PE file for the documented signatures. You should use this mode as a last option as the small signatures often tend to occur a lot in many files and so erroneous outputs may result.

The scanner's inbuilt scanning techniques have error control methods which generally ensure correct outputs even if the last mode is chosen. The first two methods produce almost instantaneous outputs but the last method is a bit slow due to obvious reasons!

https://github.com/wolfram77web/app-peid

https://www.aldeid.com/wiki/PEiD

# PKG-Unpacker

### `PKG file` | `Extractor` | `Reverse Engineering`

Unpack any pkg application.

Keep in mind that this doesn't give you the full source code if the application was compiled into V8 bytecode. See How it works.

This should work with any pkg application, but errors may occur.

This app may broke at any pkg major update.

https://github.com/LockBlock-dev/pkg-unpacker

# PMA-Labs

### `Sample Data` | `Malware Analysis`

Binaries for the book Practical Malware Analysis

Self-extracting archive
7-zip file with archive password of "malware"

https://github.com/mikesiko/PracticalMalwareAnalysis-Labs

# ProcDOT

### `PCAP Analyzer` | `Process Visualizer` | `Malware Analysis`

Welcome to ProcDOT, a new way of visual malware analysis.There are plenty of tools for behavioral malware analysis. The defacto standard ones, though, are Sysinternals’s Process Monitor (also known as Procmon) and PCAP generating network sniffers like Windump, Tcpdump, Wireshark, and the like. These “two” tools cover almost everything a malware analyst might be interested in when doing behavioral malware analysis.

But there’s a major problem with these tools. Any of them works in a so to say separated or isolated way, not knowing anything from each other. Hence it’s kinda hard to get accordingly recorded activities together in one piece or picture. That’s where ProcDOT enters the stage. It fills this actual gap by merging those records together.

But ProcDOT does much more. It turns those thousands of monitored activities into a big behavioral picture - actually a graph - which can be interactively explored making behavioral malware analysis as efficient as it never was before

https://www.procdot.com/

# Process-Dump

### `PE File` | `Reverse Engineering` | `Malware Analysis` | `Process Tool`

Process Dump is a Windows reverse-engineering command-line tool to dump malware memory components back to disk for analysis. Often malware files are packed and obfuscated before they are executed in order to avoid AV scanners, however when these files are executed they will often unpack or inject a clean version of the malware code in memory. A common task for malware researchers when analyzing malware is to dump this unpacked code back from memory to disk for scanning with AV products or for analysis with static analysis tools such as IDA.

Process Dump works for Windows 32 and 64 bit operating systems and can dump memory components from specific processes or from all processes currently running. Process Dump supports creation and use of a clean-hash database, so that dumping of all the clean files such as kernel32.dll can be skipped. It's main features include:

- Dumps code from a specific process or all processes.
- Finds and dumps hidden modules that are not properly loaded in processes.
- Finds and dumps loose code chunks even if they aren't associated with a PE file. It builds a PE header and import table for the chunks.
- Reconstructs imports using an aggressive approach.
- Can run in close dump monitor mode ('-closemon'), where processes will be paused and dumped just before they terminate.
- Multi-threaded, so when you are dumping all running processes it will go pretty quickly.
- Can generate a clean hash database. Generate this before a machine is infected with malware so Process Dump will only dump the new malicious malware components.

https://github.com/glmcdona/Process-Dump

# reg_export 

### `Registry Tool`

This program exports the raw content of a registry value to a file Usage: reg_export.exe

Example: reg_export.exe KEY_CURRENT_USER\Console CursorSize C:\output.raw

N.B. If you want the default value for a subkey, enter the value name (default)


https://github.com/adamkramer/reg_export

# RegCool - Advanced Registry Editor

### `Registry Tool` 

Advanced registry editor: RegCool is an advanced registry editor. In addition to all the features that you can find in RegEdit and RegEdt32, RegCool adds many powerful features that allow you to work faster and more efficiently with registry related tasks. Key Features - Multiple undo and redo - Search and replace - Compare registries - Cut, copy and paste - Drag and drop - Registry Snapshot - Backup and restore - Defragment. RegCool runs on all Windows versions from Windows XP onwards and is available in the following languages: English, German, French, Chinese, Spanish, Nederlands, Hungary, Russian, Portuguese and Slovenian!

https://kurtzimmermann.com/regcoolext_en.html

# Regshot 

### `Registry Tool`

Regshot is a small, free and open-source registry compare utility that allows you to quickly take a snapshot of your registry and then compare it with a second one - done after doing system changes or installing a new software product. The changes report can be produced in text or HTML format and contains a list of all modifications that have taken place between the two snapshots. In addition, you can also specify folders (with subfolders) to be scanned for changes as well. (Most of above text was copied from webattack.com, thanks :)

https://github.com/Seabreg/Regshot

# Resource Hacker

### `Reverse Engineering` | `Binary Analysis` | `Program` | `Hacking Tool`

Resource HackerTM is a resource editor for 32bit and 64bit Windows® applications. It's both a resource compiler (for *.rc files), and a decompiler - enabling viewing and editing of resources in executables (*.exe; *.dll; *.scr; etc) and compiled resource libraries (*.res, *.mui). While Resource Hacker is primarily a GUI application, it also provides many options for compiling and decompiling resources from the command-line.

https://www.angusj.com/resourcehacker/

# RunDotNetDLL

### `.NET` | `DLL` | `Malware Analysis`

RunDotNetDll allows to introspect a given .NET Assembly in order to list all the methods which are implemented in the Assembly and to invoke them. All this is done via pure Reflection using dnlib library.

I created this utility in order to easily analyze malicious .NET programs that load at runtime additional .NET Assembly. Once that you have extracted the Assembly you need a mean to run it but if it is a DLL is not so easy.

With RunDotNetDll you can invoke a specific method of the given Assembly.

https://github.com/enkomio/RunDotNetDll

# SCDBG

### `Shellcode` | `Malware Analysis`

scdbg is a shellcode analysis application built around the libemu emulation library. When run it will display to the user all of the Windows API the shellcode attempts to call.

http://sandsprite.com/blogs/index.php?uid=7&pid=152

# sclauncher

### `Shellcode` | `Debugger` | `PE File` | `Assembly`

This program is designed to load 32-bit or 64-bit shellcode and allow for execution or debugging. In addition, it can produce executable PE files based on the desired shellcode. This can ease testing as the output binary can be used by standard reverse engineering tools (i.e. IDA Pro (even free) and debuggers).

https://github.com/jstrosch/sclauncher

# sclauncher64

### `Shellcode` | `Debugger` | `PE File` | `Assembly`

A small program to load 64-bit shellcode and allow for execution or debugging. Can also output PE files from shellcode.

https://github.com/mandiant/VM-Packages/issues/893

# sfextract

### `Reverse Engineering` | `.NET`

This is a tool to extract the contents (assemblies, configuration, ...) of a single file application to a directory.

https://www.nuget.org/packages/sfextract

# shellcode_launcher

### `Shellcode` | `PE File` | `Assembly`

Shellcode launcher utility written to support the labs for the incredibly awesome book Practical Malware Analysis (http://practicalmalwareanalysis.com/)

https://github.com/clinicallyinane/shellcode_launcher

# Sysinternals

### `Toolkit` | `System Administration` | `Binary Analysis` | `Forensics`

The Sysinternals Troubleshooting Utilities have been rolled up into a single Suite of tools. This file contains the individual troubleshooting tools and help files. It does not contain non-troubleshooting tools like the BSOD Screen Saver.

The Suite is a bundling of the following selected Sysinternals Utilities: AccessChk, AccessEnum, AdExplorer, AdInsight, AdRestore, Autologon, Autoruns, BgInfo, BlueScreen, CacheSet, ClockRes, Contig, Coreinfo, Ctrl2Cap, DebugView, Desktops, Disk2vhd, DiskExt, DiskMon, DiskView, Disk Usage (DU), EFSDump, FindLinks, Handle, Hex2dec, Junction, LDMDump, ListDLLs, LiveKd, LoadOrder, LogonSessions, MoveFile, NotMyFault, NTFSInfo, PendMoves, PipeList, PortMon, ProcDump, Process Explorer, Process Monitor, PsExec, PsFile, PsGetSid, PsInfo, PsKill, PsList, PsLoggedOn, PsLogList, PsPasswd, PsPing, PsService, PsShutdown, PsSuspend, PsTools, RAMMap, RDCMan, RegDelNull, RegHide, RegJump, Registry Usage (RU), SDelete, ShareEnum, ShellRunas, Sigcheck, Streams, Strings, Sync, Sysmon, TCPView, VMMap, VolumeID, WhoIs, WinObj, ZoomIt

https://learn.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite

# Systeminformer

### `Forensics` | `System Monitoring` | `Debugger`

A free, powerful, multi-purpose tool that helps you monitor system resources, debug software and detect malware.

https://systeminformer.sourceforge.io/

# UniExtract2

### `Extractor` | `Decompressor`

Universal Extractor 2 is a tool designed to extract files from any type of extractable file.

Unlike most archiving programs, UniExtract is not limited to standard archives such as .zip and .rar. It can also deal with application installers, disk images and even game archives and other multimedia files. An overview of supported file types can be found here

This program is an unofficial updated and extended version of the original UniExtract by Jared Breland. As the development of the original version has stopped and no update has been published for years, many forks (modified versions, maintained by volunteers from the community) have arisen. This is the most advanced of them, featuring a very long list of enhancements.

https://github.com/Bioruebe/UniExtract2

# UPX

### `Extractor` | `DLL` | `PE Files` | `ELF Files` | `macOS`

UPX is a free, secure, portable, extendable, high-performance executable packer for several executable formats.

### Introduction
UPX is an advanced executable file compressor. UPX will typically reduce the file size of programs and DLLs by around 50%-70%, thus reducing disk space, network load times, download times and other distribution and storage costs.

Programs and libraries compressed by UPX are completely self-contained and run exactly as before, with no runtime or memory penalty for most of the supported formats.

UPX supports a number of different executable formats, including Windows programs and DLLs, macOS apps and Linux executables.

UPX is free software distributed under the term of the GNU General Public License. Full source code is available.

UPX may be distributed and used freely, even with commercial applications.

https://upx.github.io/

# vcbuildtools

### `Visal C++` | `Toolkit`
Visual C++ Build Tools 2015 provides the required tools for building C++ applications and libraries targeting Windows desktop. If you want to build your C++ projects targeting Windows desktop without having Visual Studio installed on your computer, Visual C++ Build Tools 2015 provides C++ compilers libraries, build scripts, and Windows SDKs.

The default installation includes the Visual C++ compiler toolset, libraries and MSBuild for Windows Desktop development.

https://community.chocolatey.org/packages/vcbuildtools

# vcredist-all

### `Visual C++` | `Toolkit`

Microsoft Visual C++ Redistributable installs run-time components of Visual C++ libraries. These components are required to run C++ applications that are developed using Visual Studio and link dynamically to Visual C++ libraries. The packages can be used to run such applications on a computer even if it does not have Visual Studio installed. These packages also install run-time components of C Runtime (CRT), Standard C++, MFC, C++ AMP, and OpenMP libraries.

This metapackage installs packages for all Visual C++ Runtime releases since 2005.

(Yes, dependencies on vcredist2015 and vcredist2017 are redundant, but are included here because other packages depend on them.)

https://community.chocolatey.org/packages/vcredist-all

# VSCode (1.92.1 as of 08122024)

### `Code Editor` | `Toolkit` | `IDE`

Visual Studio Code is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, macOS and Linux. It comes with built-in support for JavaScript, TypeScript and Node.js and has a rich ecosystem of extensions for other languages and runtimes (such as C++, C#, Java, Python, PHP, Go, .NET). 

https://community.chocolatey.org/packages/vscode

# windbg (8.59.20160823 as of 20240812)

### `Debugger` | `Windows Debugger`

Microsoft Windows Debugger (WinDbg) is a powerful Windows-based debugger that is capable of both user-mode and kernel-mode debugging. WinDbg provides debugging for the Windows kernel, kernel-mode drivers, and system services, as well as user-mode applications and drivers. ***This Package will add an environment variable pointing to the Microsoft symbols and will also copy sos.dll from the most recent .net runtime on your machine to the same directory where windbg.exe is installed.

https://community.chocolatey.org/packages/windbg

# windows-terminal

### `terminal` 

The new Windows Terminal and the original Windows console host, all in the same place!

https://github.com/microsoft/terminal

# Wireshark

### `Network Tools` | `Packet Capture`

#### The world's most popular network protocol analyzer

Get started with Wireshark today and see why it is the standard across many commercial and non-profit enterprises.

https://www.wireshark.org/

# x64dbg

### `Debugger` | `Assembly` | `x86` | `x64`

An open-source x64/x32 debugger for windows.

https://x64dbg.com/

### x64dbg Plugins

### DbgChild Plugin

https://github.com/therealdreg/DbgChild

### OllyDumpEx Plugin

https://low-priority.appspot.com/ollydumpex/

### ScyllaHide Plugin

https://github.com/x64dbg/ScyllaHide


### x64dbgpy Plugin 

https://github.com/x64dbg/x64dbgpy

### Other plugins 

https://github.com/x64dbg/x64dbg/wiki/Plugins


# YARA

YARA is a tool aimed at (but not limited to) helping malware researchers to identify and classify malware samples. With YARA you can create descriptions of malware families (or whatever you want to describe) based on textual or binary patterns. Each description, a.k.a rule, consists of a set of strings and a boolean expression which determine its logic.

https://virustotal.github.io/yara/