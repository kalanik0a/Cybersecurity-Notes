# Malware Behaviors

## Common Patterns
- `Backdoors`: A method of enabling communications or access by modifying programs or components of the OS so an attacker may access the target system
- `Reverse Shell`: A method of making a remote server available to allow communications.
    - Common reverse shells: `meterpreter`, `netcat`, `SSH reverse bind`
- `Remote Access Technology` or `Remote Administration Tool` or `Remote Access Trojan`: A program which is used soley for the purpose of remote communication
    - `Poison IVY RAT`
- `Botnets`: Programs which structure the Server Oriented Architecture so that way collections of infected computers respond to a centralized administration structure like a `C2 (Command and Control)` domain or program
- `Credential Stealers`: Programs which are designed to steal credentials and other pieces of information like `Lumma Stealer`, `Redline`, and `Gremlin`
- `Hash Dumping`: A method of getting password hashes from components like `Security Account Manager (SAM)` or `Local Security Authority Subsystem Service (LSASS)`
    - Other attacks include `Kerberoasting`, `Pass the Hash`, `Pass the Ticket`
- `Keylogging`: A method commonly used by Spyware to record what the user writes inside of their computer. Collecting things like credentials and other juicy information
    - Kernel-based keyloggers: Using things like drivers and kernel modules and .SYS files to record information
    - User-based keyloggers: Background processes, trojans, and other programs
        - `SetWindowsHookEx`, `GetAsyncKeyState`, `GetForegroundWindow`
- `Trojanized Function Calls`: When a DLL or EXE or other PE file is patched to where the desired function call is replaced with a Trojanized call that performs additional computation and then passes the return to the original desired function call
- `DLL Load-Order Hijacking`: Allows attackers to create malicious entry points for different programs to override original desired calls.
- `Privilege Escalation`: The action of utilizing programs, services, executables, or routines with the details of Root, Administrator, System, or Trusted credentials to escalate the available permissions within the OS.
    - This may include calls to the `SeDebugPrivilege`
- `User-Mode Rootkits`: Program libraries, code, routines, and executables that modify the functionality or side-effects of activities within a system to conceal the presence of a malicious process, or spyware. 
    - `SSDT Hooking`
    - `IRP Hooks`
    - `Import Address Table Hooking` 
    - `Export Address Table Hooking`
    - `Inline Hooking`
# Common Registry Keys

```
# Autostart Entries
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run

# AppInit_DLLs
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows

# Windows Logon Startup Entries
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\

# SvcHost DLLs
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost

# Windows Services
HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\
```

# Malware Launching

## Process Injection
One of the most common injection tactics is using `VirtualAllocEx` and `WriteProcessMemory` to inject malicious code into a process.

## DLL Injection
Abusing the `OpenProcess`, `VirtualAllocEx`, `WriteProcessMemory`, `GetModuleHandle`, `GetProcAddress`, and `CreateRemoteThread` calls to inject a DLL into a given process. First the process is opened with `OpenProcess`, then `VirtualAllocEx` and `WriteProcessMemory` is used to allocate space. Then `GetProcAddress` is used to get the address to `LoadLibrary`. Finally `CreateRemoteThread` is passed the locations of the DLLs to be loaded into the remote process thread.

## Process Hollowing and Direct Injection
https://attack.mitre.org/techniques/T1055/012/

## Process Replacement
Using the `CREATE_SUSPENDED` `dwCreationFlags` to create a process, and then replace the process memory of the suspended process is loaded into the desired process.

## Hook Injection
Using Windows function call hooks to intercept messages transmitted to threads, processes, and binaries, and then reading them or modifying them to change what happens between the function call or after the function call for a desired effect. Hooks may be `Local` or `Remote` and may be high or low level. Examples of hooks may be the `WH_KEYBOARD` or `WH_KEYBOARD_LL` hook procedure types. Also the `SetWindowsHookEx` window hook, `WH_CBT`, and `CallNextHookEx` hooks. Utilizing the `.detours` section can also modify what DLL is called within a PE File.

## APC Injection
Asynchronous Procedure Calls (APC) can direct a thread to execute code prior to its regular execution path. Using functions like `WaitForSingleObjectEx`, `WaitForMultipleObjectsEx` and `Sleep`. Modifying calls like `CreateToolhelp32Snapshot`, `Process32First`, `Process32Next`, `Thread32First`, and `Thread32Next` can help achieve APC Injection. Later on the `QueueUserAPC` call is used to add things like `LoadLibraryA`. Kernel APC injection uses `KeInitializeApc` and `KeInsertQueueApc` to include things like rootkits.

## String which may indicate ciphers like base64
```
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
```

# Anti-Disassembly
### Jump Instructions with the same target
```
jz loc_512
jnz loc_512
```

## Jump Instruction with a constant condition
When a program clears a flag to execute a jump instruction. Such as clearing the `ZF` or `ZeroFlag`
```
xor eax, eax
jz near ptr loc_4011C4+1
```

## Impossible Disassembly
Doing things like a 4-byte sequence with a 2-byte `jmp` instruction to jump to the second byte.
```
JMP -1
EB FF C0 F8
```

```
66 B8 EB 05         mov ax, 5EBh
31 C0               xor eax, eax
74 F9               jz short near ptr sub_4011C0+1
                loc_4011C8:
E8 58 C3 90 90      call near ptr 98A8D525h
```
```
66                  byte_4011C0 db 66h
B8                              db 0B8h
EB                              db 0EBh
05                              db 5
; ------------------------------------------------------------
31 C0               xor eax, eax
; ------------------------------------------------------------
74                              db 74h
F9                              db 0F9h
E8                              db 0E8h
; ------------------------------------------------------------
58                  pop eax
C3                  retn
```

## Return Pointer Abuse
```
004011C0 sub_4011C0 proc near ; CODE XREF: _main+19p
004011C0 ; sub_401040+8Bp
004011C0
004011C0 var_4 = byte ptr -4
004011C0
004011C0 call $+5
004011C5 add [esp+4+var_4], 5
004011C9 retn
004011C9 sub_4011C0 endp ; sp-analysis failed
004011C9
004011CA ; ------------------------------------------------------------
004011CA push ebp
004011CB mov ebp, esp
004011CD mov eax, [ebp+8]
004011D0 imul eax, 2Ah
004011D3 mov esp, ebp
004011D5 pop ebp
004011D6 retn
```

# Anti-Debugger

## Windows API Calls
```c
IsDebuggerPresent
CheckRemoteDebuggerPresent
NtQueryInformationProcess
    0x7 - ProcessDebugPort
OutputDebugString
```
## OutputDebugString Test
```c
DWORD errorValue = 12345;
SetLastError(errorValue);
OutputDebugString("Test for Debugger");

if(GetLastError() == errorValue) {
    ExitProcess();
} else {
    RunMaliciousPayload();
}
```

## Flags
```
BeingDebugged
# ProcessHeap
    mov eax, large fs:30h
    mov eax, dword ptr [eax+18h]
    cmp dword ptr ds:[eax+10h], 0
    jne DebuggerDetected

# NTGlobalFlag
    mov eax, large fs:30h
    cmp dword ptr ds:[eax+68h], 70h
    jz DebuggerDetected
```

## Residues
- Registry Keys
- DLLs which indicate VMs
- Debugger paths
- Running processes of tools
- Checking for debugger opcodes
    - 0xCD
    - 0xCC

## Checking for Windows
```cpp
if (FindWindow("OLLYDBG", 0) == NULL) {
    // Debugger not found
} else {
    // Debugger detected
}
```

## Performing Instruction or Memory Hashing
- Using CRC or an MD5 checksum of the opcodes to detect a debugger

## Timing Checks
- If program flow execution takes longer than expected, then it is possible that a debugger is inspecting the process

## Using TLS Callbacks
- Thread Local Storage
    - Check with a binary explorer for a TLS table
    - Use Debugger configuration to detect TLS calls
- These can be used to load code into the program when being loaded into a debugger.

## Kernel Access Violations
- Kernel Access Violations
    - OllyDbg has the ability to ignore memory access violations for KERNEL32


## Inserting Interrupts
- Interrupts can break execution flow on certain debugger breakpoints which would otherwise not occur in a non-debugged process.

## Debugger Vulnerabilities
- PE Header vulnerabilities
- Invalid NumberOfRvaAndSizes
- Invalid IMAGE_OPTIONAL_HEADER sizes
- Invalid IMAGE_NUMBEROF_DIRECTORY_ENTRIES
- OutputDebugString vulnerability like `OutputDebugString("%s%s%s%s%s%s%s%s%s%s%s%s%s%s")`

## VM Detection
```
VMwareService.exe
VMWwareTray.exe
VMwareUser.exe
```
- Detection of `open-vm-tools`
- Detection of VMware Tools in client
- Detection of VirtualBox guest additions
- Checking the Global Descriptor Table (GDT)
- Checking the Local Descriptor Table (LDT)
- Checking the Interrupt Descriptor Table (IDT)
### Anti-VM x86 Insturctions
```
sidt
sgdt
sldt
smsw
str
in
cpuid
```